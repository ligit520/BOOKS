**C++教程**

------





[toc]





# 友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。

友元提供了另一访问类的私有成员的方案。友元有三种：

- 友元全局函数。

- 友元类。

- 友元成员函数。

1）友元全局函数

 在友元全局函数中，可以访问另一个类的所有成员。

2）友元类

在友元类所有成员函数中，都可以访问另一个类的所有成员。

友元类的注意事项：

- 友元关系不能被继承。

- 友元关系是单向的，不具备交换性。

若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。

3）友元成员函数

在友元成员函数中，可以访问另一个类的所有成员。

如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：

class CGirl;      // 前置声明。  

class CBoy { ...... };   // CBoy的定义。

class CGirl { ...... };   // CGirl的定义。            

// 友元成员函数的定义。        

void CBoy::func(CGirl &g) { ...... }    



# 运算符重载

## 重载关系运算符+-*/

## 重载左移运算符

## 重载下标运算符

## 重载赋值运算符

## 重载new&delete运算符

## 重载括号运算符

## 重载一元运算符



# 内存池



# 继承

## 继承的定义

继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。

语法：

class 派生类名:［继承方式］基类名

{

  派生类新增加的成员

}; 

被继承的类称为基类或父类，继承的类称为派生类或子类。



# 自动推导auto



# 函数模板

## 函数模板的基本概念

函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。

编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。

生成函数定义的过程被称为实例化。

创建交换两个变量的函数模板：

```c++
template <typename T>
void Swap(T &a, T &b)
{
   T tmp = a;
   a = b;
   b = tmp;
}
```

函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式的指定。

## 函数模板的具体化



## 函数模板的分文件编写



## 函数模板高级

decltype关键字

函数后置返回类型

# 模板类

## 模板类的基本概念

类模板是通用类的描述，使用任意类型（泛型）来描述类的定义。

函数模板建议用typename描述通用数据类型，类模板建议用class。

```c++
template <class T>
class 类模板名
{
   类的定义;
};
```

## 栈



## 数组



## 嵌套使用模板类（二维容器）



## 模板类具体化

模板类具体化（特化、特例化）有两种：完全具体化和部分具体化。

具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。



## 模板类与继承

1）模板类继承普通类（常见）。

2）普通类继承模板类的实例化版本。

3）普通类继承模板类。(常见)

4）模板类继承模板类。

5）模板类继承模板参数给出的基类（不能是模板类）。





# vector

vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。

```c++
#include <iostream>        // 包含头文件。
#include<string>
#include <iomanip>
#include<vector>			//导入vector头文件
using namespace std;        // 指定缺省的命名空间。


int main()
{
	vector<int> v1(10); 	//初始v1内为10个0
	int nSize = v1.size();  //v1的元素个数

	for (int i = 0; i < 10; i++){
		v1[i] = i;                //逐个赋值
	}

	for (int i = 0; i < nSize; i++)  //逐个输出
	{
		cout << v1[i] << " ";
	}
	cout << endl;


	system("pause");
	return 0;

}



```

## 初始化

```c++
vector<int> v1;            //对v1执行默认初始化
vector<int> v2(v1);        //v2初始化为包含v1的所有元素的拷贝
vector<int> v3(n,x);       //v3包括了n个元素，都为x(x可省略)，也可以使用{}代替()
vector<int> v4 = (1,2,3....)    //v4初始化为(1，2，3...)

```



## 下标访问、修改元素

```c++
for (int i = 0; i < nSize; i++)  //逐个输出
	{
		cout << v1[i] << " ";
	}
	cout << endl;

for (int i = 0; i < 10; i++){
		v1[i] = i;                //逐个赋值
	}
```



## 向量尾部插入/删除元素

```c++
vector<int> v2;
	for (int i = 0; i<10; i++){
		v2.push_back(i);            //末尾逐个添加元素
	}

v2.pop_back();		////直接删除队尾最后一个的元素
```



## 使用迭代器访问元素

```cpp
vector<int>::iterator it;
for(it=array.begin();it!=array.end();it++)
    cout<<*it<<endl;
```



```c++
vector<int> v1;
vector<int> v2;
v1.insert(v1.begin(),x);        //在v1开始位置插入x
v1.insert(v1.begin(),n,x);      //在v1结束位置插入n个x
v1.insert(v1.begin(),v2.begin(),v2.end());    //将v2整个插入v1开始位置
```



```c++
v1.empty()           //如果v1为空返回真，否则假
v1.clear()           //清空v1，使其为空
v1.size()            //返回v1的大小
v1.remove(x)         //移除所有大小等于x的元素，但不会改变容器的大小
v1.erase(v1.begin()+2)    //删除v1的第三个元素，总size减1，并且返回下一个元素的迭代器
v1 ` v2                  //当v1与v2元素数量与大小相同时为真
a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
a.reserve(100); //将a的容量（capacity）扩充至100
a.swap(b); //将a中的元素和b中的元素进行整体性交换
向量的比较操作 ` != >= <= > <  
a`b;
    
    
    
```



## 排序、查找操作（需要导入algorithm）

```c++
//下面函数需要引入 algorithm
#include<algorithm>

sort(v1.begin(),v1.end());        //对整个v1进行排序（从小到大）
sort(v1.rbegin(),v1.rend());      //对整个v1进行排倒序（从大到小）

find(a,b,x)                          //在a到b范围内寻找值为x的对象，
i=find(v1.begin(),v1.end(),x)        //在v1中寻找是否有值为5的存在
                            //找到则返回该位置的迭代器，没有则返回结束位置下一个的迭代器
i-v1.begin()                //如果找到，该式则为该元素位置
```



