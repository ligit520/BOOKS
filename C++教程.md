# C++

[toc]



# 数据类型

## 有符号、无符号

char

int

short

long

long long



## 浮点数float double   long double

## 转义字符

\n 换行



## 字符

字符的本质是整数，取值范围是0～127。



## 字符串

C++风格字符串：string 变量名="字符串的内容" ;

C风格字符串：char 变量名[]="字符串的内容" ;

C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。

C++风格字符串的常用操作：

赋值：变量名="字符串的内容" ;

拼接：变量名=变量名+"字符串的内容一"+"字符串的内容一"+......+"字符串的内容" ;

如果字符串的内容都是常量，不要写加号（+），如果内容很长，可以分成多行书写。

比较：支持==、!=、>和<关系运算符，常用的是==和!=。



## bool

用0表示假，非0表示真



# sizeof运算符

sizeof运算符用于求数据类型或变量占用的内存空间。

用于数据类型：sizeof(数据类型)

用于变量：sizeof(变量名) 或 sizeof 变量名

注意：

l 在32位和64位操作系统中，同一种数据类型占用的内存空间可能不一样。

l 字符串（string）不是C++的基本数据类型，用sizeof求它占用内存的大小没有意义。

# 变量

变量命名规则

变量的定义和初始化

# 修饰符





# 常量



# 运算符

## 算术运算

| **运算符** | **描述**                 |
| ---------- | ------------------------ |
| **+**      | 两个数相加。             |
| **-**      | 一个数减另一个数。       |
| *****      | 两个数相乘。             |
| **/**      | 分子除以分母。           |
| **%**      | 取模运算，整除后的余数。 |

| **运算符**       | **描述**                            |
| ---------------- | ----------------------------------- |
| **++****变量名** | 先把变量的值加1，然后再执行表达式。 |
| **变量名++**     | 先执行表达式，再把变量的值加1。     |
| **--****变量名** | 先把变量的值减1，然后再执行表达式。 |
| **变量名--**     | 先执行表达式，再把变量的减1。       |

## 自增和自减

| **运算符** | **示例**                        | **描述**                                                     |
| ---------- | ------------------------------- | ------------------------------------------------------------ |
| **=**      | c = a + b; 将把a + b的值赋给c。 | 把右边操作数的值赋给左边操作数。                             |
| **+=**     | c += a; 相当于 c = c + a;       | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数。 |
| **-=**     | c -= a; 相当于 c = c - a;       | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数。 |
| ***=**     | c *= a; 相当于 c = c * a;       | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数。 |
| **/=**     | c /= a; 相当于 c = c / a;       | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数。 |
| **%=**     | c %= a; 相当于 c = c % a;       | 求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。 |

## 关系运算符

| **关系** | **数学的表示** | **C++****的表示** |
| -------- | -------------- | ----------------- |
| 等于     | =              | ==                |
| 不等于   | ≠              | !=                |
| 小于     | <              | <                 |
| 小于等于 | ≤              | <=                |
| 大于     | >              | >                 |
| 大于等于 | ≥              | >=                |

## 逻辑运算符

| **运算符** | **术语**     | **示例** | **结果**                                                   |
| ---------- | ------------ | -------- | ---------------------------------------------------------- |
| &&         | 逻辑与       | a&&b;    | 如果a和b都为真，则结果为真，否则为假。                     |
| \|\|       | 逻辑或       | a\|\|b;  | 如果a和b中有一个为真，则结果为真，二者都为假时，结果为假。 |
| !          | 逻辑非（反） | !a;      | 如果a为假，则!a为真； 如果a为真，则!a为假。                |

## 运算符的优先级



# 循环和判断

## if语句

```c++
if (表达式)
{
  // 表达式为真时执行的语句。
}
else
{
  // 表达式为假时执行的语句。
}
```



## 嵌套if

```c++
if (表达式一)
{ 
  if (表达式二) 
  {
    // 表达式二为真时执行的语句。
  }
    else
    {
      // 表达式二为假时执行的语句。
  }
}
else
{
  // 表达式一为假时执行的语句。
}
```



## 多条件if

```c++
if (表达式一)
{ 
  // 表达式一为真时执行的语句。
}
else if (表达式二)
{
  // 表达式二为真时执行的语句。
}
else if (表达式三)
{
  // 表达式三为真时执行的语句。
}
……

else if (表达式n)
{
  // 表达式n为真时执行的语句。
}
else
{
  // 全部表达式都不为真时执行的语句。
}
```



## 三目运算

三目运算也叫条件运算或三元运算，可以实现简单if语句的功能，但是书写更简洁。

语法： 表达式一 ? 表达式二 : 表达式三



## switch语句

```c++
switch (表达式)
{
  case 值一: 
    语句一; 
    break;
  case 值二: 
    语句二; 
    break;
  ......
  case 值n: 
    语句n; 
    break;
  default: 
    上述条件都不满足时执行的语句;
}
```

注意：

+ `case`后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能使用变量。

+ `default`不是必须的，当没有`default`时，如果全部的`case`匹配失败，那么就什么都不执行。

+ 每个分支不要漏写`break;`语句。



## while语句

```c++
while (表达式)
{
    语句块
}
```

先计算表达式的值，如果为真就执行语句块，执行完语句块后，回到循环首部再次计算表达式的值，如果为真又执行一次语句块……，这个过程会一直重复，直到表达式的值为假时不再执行语句块。

注意：

l 如果表达式的值永远为真，那么将进入死循环，所以在循环中应该有改变表达式的值的方法。

l 如果循环体中的语句块只有一行代码，大括号可以不书写。



## break和continue

break和continue两个关键字用于控制循环体中代码的执行流程。

break跳出（中止）当前循环语句。

continue回到当前循环语句的首部。



## for循环

```c++
for (语句一 ; 表达式 ; 语句二)
{
  语句块
}
```

1）循环开始的时候，先执行语句一，在整个循环过程中语句一只会被执行一次。

2）计算表达式的值，如果为真，就执行一次循环体中的语句块。

3）执行完语句块后，执行一次语句二。

4）重复第2）步和第3），直到表达式的值不为真才结束for循环。



## goto语句

goto语句也称为无条件转移语句。

goto的语法：goto 语句标号;



# 函数

## 声明和定义函数

返回值的数据类型 函数名(参数一的数据类型 参数一, 参数二的数据类型 参数二,……)

{

  实现函数功能的代码。

  return 返回值;

}



## 函数的调用

| **调用类型** | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| 传值调用     | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| 指针调用     | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| 引用调用     | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |



## 函数的递归

一个函数可以调用另一个函数，作为特例，如果函数调用了自己，就像故事中提到了同样的故事一样，我们把函数在运行时调用自己的情况叫做递归。

递归函数中一定要有递归终止的条件，否则是死递归。



## 函数分文件编写

**头文件（\*.h）**：需要包含的头文件，声明全局变量，函数的声明，数据结构和类的声明等。

**源文件（\*.cpp）**：函数的定义、类的定义。

主程序：main函数，程序的核心流程，需要用#include "头文件名"把头文件包含进来。



# 变量的作用域

变量分**全局变量**和**局部变量**两种，全局变量在整个程序中都可以访问，局部变量只能在函数或语句块的内部才能访问。

C++中定义变量的场景主要有五种：

1）在全部函数外面定义的是全局变量。

2）在头文件中定义的是全局变量。

3）在函数和语句块内部定义的是局部变量。

4）函数的参数是该函数的局部变量。

5）函数内部用static修饰的是静态局部变量。





# 数组



# 字符串



# 指针



# 引用





# 结构体struct

C/C++ 数组允许定义可存储相同类型数据项的变量，但是`结构体`是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

## 结构体的定义

```c++
格式为：struct 结构体名 对象名;

struct type_name 
{ 
    member_type1 member_name1; 
    member_type2 member_name2; 
    member_type3 member_name3; 
};

当我们用typedef定义struct的别名后，可以直接用 别名 对象名 来声明一个对象。
typedef struct tagPOINT1
{
    int x;
    int y;
}POINT;
POINT p1;

//变量初始化和打印
p1.x = 10;
cout << p1.x << endl;
```



# 枚举enum

枚举(enumeration)和类相似，能够定义一种新的数据类型，不同的是，枚举是将一组整形常量组织在一起

## 枚举的初始化

**1.默认情况下，枚举值从0开始，依次加1**

```cpp
	enum color
	{
		RED,  //默认是0
		GREEN, //默认是1
		BLUE  //默认是2
	};
```

### 2.手动指定枚举值

**a.可以全部指定**

```cpp
	enum color
	{
		RED=1,  
		GREEN=5, 
		BLUE=7  
	};
```

**b.可以部分指定，未被初始化的枚举值的值默认将比其前面的枚举值大1**

```cpp
	enum color
	{
		RED=2,  
		GREEN,  //默认值是3，比前一个多1
		BLUE=7  
	};
```

## 指定枚举类型

C++11中，还可以指定给枚举类型赋值的整数类型，在enum的名字后面加上冒号以及指定的类型，限定作用域枚举默认为32位整形，在某些情况下，甚至没必要用到32位，为了节省开销，甚至可以用8位整形unsigned char，将类型指定成后，枚举变量变成了8位整型，减少了内存使用。不限定作用域的枚举类型，其成员不存在默认类型，只需要知道潜在类型是足够大的，肯定能容纳枚举值就行。

需要注意的是，不能指定为float或者double等类型，因为枚举量必须是一个整数，float和double都不是整数。

```cpp
	enum color:unsigned long
	{
		RED=1,  
		GREEN=5, 
		BLUE=7  
	};
```

## 声明枚举对象

**a.先声明变量，再对变量赋值**

```c++
#include <iostream>
using namespace std;

int main()
{
	enum color
	{
		RED,
		GREEN,
		BLUE
	};
enum color backColor, frontColor, innerColor;
 
backColor = RED;
frontColor = GREEN;
innerColor = BLUE;
 
cout << backColor << "--" << frontColor << "--" << innerColor << endl;
system("pause");
return 0;
}
```
**b.声明变量的同时赋初值**

	#include <iostream>
	using namespace std;
	
	int main()
	{
		enum color
		{
			RED,
			GREEN,
			BLUE
		};
	enum color backColor = RED, frontColor = GREEN, innerColor = BLUE;
	 
	cout << backColor << "--" << frontColor << "--" << innerColor << endl;
	system("pause");
	return 0;
	}
**c.定义类型的同时声明变量，然后对变量赋值**



	#include <iostream>
	using namespace std;
	
	int main()
	{
		enum color
		{
			RED,
			GREEN,
			BLUE
		}backColor, frontColor, innerColor;
	backColor = RED;
	frontColor = GREEN;
	innerColor = BLUE;
	 
	cout << backColor << "--" << frontColor << "--" << innerColor << endl;
	system("pause");
	return 0;
	}
**d.类型定义，变量声明，赋初值同时进行**

	#include <iostream>
	using namespace std;
	
	int main()
	{
		enum color
		{
			RED,
			GREEN,
			BLUE
		}backColor = RED, frontColor = GREEN, innerColor = BLUE;
	cout << backColor << "--" << frontColor << "--" << innerColor << endl;
	system("pause");
	return 0;
	}




# 类与对象class



## 类的创建



## 类的访问权限



## 构造函数



## 析构函数



## 拷贝构造函数



## 静态成员





# 浅拷贝和深拷贝

两个指针指向同一块内存



- strcpy(char* des,const char* source)

把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间

说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。



- memcpy （void* _Dst,void const* _Src,size_t _Size）

  作用：将Src数组中的内容复制Size个字节长度，给到Dst数组。

  注意:指针是用void修饰的，所以_Dst和_Src两个指针都是由原有的数据类型强制转换为void类型进行操作的，这样，不同类型之间就可以进行复制传值操作了，但是要注意的一点是，不同类型之间的数据长度不同，所以在复制时候要注意匹配相同的数据长度。此外，在进行处理时，最好采用16进制的方式去操作，这样理解起来更为直观。

```c++
char a[8]={0x12,0x34,0x56,0x78,0x90,0x14,0x52,0x46 };
short b=0;
memcpy(&b,a+1,2);
printf("b=%x", b);
```

此段代码的作用是把0x34和0x56拼接起来送到b，输出的最终结果是：0x5634。
输出用的是%x，表示以十六进制进行输出。
char型数据占用一个字节，而short型数据占用两个字节，所以把char型数据拷贝到short型数据中时，传递的字节长度是2，如果把char型数据传递给int型数据，传递的字节长度应该是4。
拼接的时候低字节放在低位，高字节放在高位。
此外，memset函数在对数组进行赋值的过程中，在dest的末尾不会追加结束符’\0’，因此，在使用此函数时，一般不要把目标数组全部占用，留一位写’\0’.



# 友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。

友元提供了另一访问类的私有成员的方案。友元有三种：

- 友元全局函数。

- 友元类。

- 友元成员函数。

1）友元全局函数

 在友元全局函数中，可以访问另一个类的所有成员。

2）友元类

在友元类所有成员函数中，都可以访问另一个类的所有成员。

友元类的注意事项：

- 友元关系不能被继承。

- 友元关系是单向的，不具备交换性。

若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。

3）友元成员函数

在友元成员函数中，可以访问另一个类的所有成员。

如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：

class CGirl;      // 前置声明。  

class CBoy { ...... };   // CBoy的定义。

class CGirl { ...... };   // CGirl的定义。            

// 友元成员函数的定义。        

void CBoy::func(CGirl &g) { ...... }    



# 运算符重载

## 重载关系运算符+-*/

## 重载左移运算符

## 重载下标运算符

## 重载赋值运算符

## 重载new&delete运算符

## 重载括号运算符

## 重载一元运算符



# 内存池



# 继承

## 继承的定义

继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。

语法：

class 派生类名:［继承方式］基类名

{

  派生类新增加的成员

}; 

被继承的类称为基类或父类，继承的类称为派生类或子类。



# 自动推导auto



# 函数模板

## 函数模板的基本概念

函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。

编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。

生成函数定义的过程被称为实例化。

创建交换两个变量的函数模板：

```c++
template <typename T>
void Swap(T &a, T &b)
{
   T tmp = a;
   a = b;
   b = tmp;
}
```

函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式的指定。

## 函数模板的具体化



## 函数模板的分文件编写



## 函数模板高级

decltype关键字

函数后置返回类型

# 模板类

## 模板类的基本概念

类模板是通用类的描述，使用任意类型（泛型）来描述类的定义。

函数模板建议用typename描述通用数据类型，类模板建议用class。

```c++
template <class T>
class 类模板名
{
   类的定义;
};
```

## 栈



## 数组



## 嵌套使用模板类（二维容器）



## 模板类具体化

模板类具体化（特化、特例化）有两种：完全具体化和部分具体化。

具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。



## 模板类与继承

1）模板类继承普通类（常见）。

2）普通类继承模板类的实例化版本。

3）普通类继承模板类。(常见)

4）模板类继承模板类。

5）模板类继承模板参数给出的基类（不能是模板类）。





# vector

vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。

```c++
#include <iostream>        // 包含头文件。
#include<string>
#include <iomanip>
#include<vector>			//导入vector头文件
using namespace std;        // 指定缺省的命名空间。


int main()
{
	vector<int> v1(10); 	//初始v1内为10个0
	int nSize = v1.size();  //v1的元素个数

	for (int i = 0; i < 10; i++){
		v1[i] = i;                //逐个赋值
	}

	for (int i = 0; i < nSize; i++)  //逐个输出
	{
		cout << v1[i] << " ";
	}
	cout << endl;


	system("pause");
	return 0;

}



```

## 初始化

```c++
vector<int> v1;            //对v1执行默认初始化
vector<int> v2(v1);        //v2初始化为包含v1的所有元素的拷贝
vector<int> v3(n,x);       //v3包括了n个元素，都为x(x可省略)，也可以使用{}代替()
vector<int> v4 = (1,2,3....)    //v4初始化为(1，2，3...)

```



## 下标访问、修改元素

```c++
for (int i = 0; i < nSize; i++)  //逐个输出
	{
		cout << v1[i] << " ";
	}
	cout << endl;

for (int i = 0; i < 10; i++){
		v1[i] = i;                //逐个赋值
	}
```



## 向量尾部插入/删除元素

```c++
vector<int> v2;
	for (int i = 0; i<10; i++){
		v2.push_back(i);            //末尾逐个添加元素
	}

v2.pop_back();		////直接删除队尾最后一个的元素
```



## 使用迭代器访问元素

```cpp
vector<int>::iterator it;
for(it=array.begin();it!=array.end();it++)
    cout<<*it<<endl;
```



```c++
vector<int> v1;
vector<int> v2;
v1.insert(v1.begin(),x);        //在v1开始位置插入x
v1.insert(v1.begin(),n,x);      //在v1结束位置插入n个x
v1.insert(v1.begin(),v2.begin(),v2.end());    //将v2整个插入v1开始位置
```



```c++
v1.empty()           //如果v1为空返回真，否则假
v1.clear()           //清空v1，使其为空
v1.size()            //返回v1的大小
v1.remove(x)         //移除所有大小等于x的元素，但不会改变容器的大小
v1.erase(v1.begin()+2)    //删除v1的第三个元素，总size减1，并且返回下一个元素的迭代器
v1 == v2                  //当v1与v2元素数量与大小相同时为真
a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
a.reserve(100); //将a的容量（capacity）扩充至100
a.swap(b); //将a中的元素和b中的元素进行整体性交换
向量的比较操作 == != >= <= > <  
a==b;
    
    
    
```



## 排序、查找操作（需要导入algorithm）

```c++
//下面函数需要引入 algorithm
#include<algorithm>

sort(v1.begin(),v1.end());        //对整个v1进行排序（从小到大）
sort(v1.rbegin(),v1.rend());      //对整个v1进行排倒序（从大到小）

find(a,b,x)                          //在a到b范围内寻找值为x的对象，
i=find(v1.begin(),v1.end(),x)        //在v1中寻找是否有值为5的存在
                            //找到则返回该位置的迭代器，没有则返回结束位置下一个的迭代器
i-v1.begin()                //如果找到，该式则为该元素位置
```



